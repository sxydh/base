package cn.net.bhe.basics.jvm.classload.init;

import org.junit.jupiter.api.Test;

/**
 * 初始化阶段是执行类构造器<clinit>()方法的过程。
 * 
 * ▪ <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中
 * 出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
 * ▪ <clinit>()方法与类的构造函数(或者说实例构造器<init>()方法)不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，
 * 父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。
 * ▪ 由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
 * ▪ <clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。
 * ▪ 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法
 * 不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
 * ▪ 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，
 * 其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中
 * 这种阻塞往往是很隐蔽的。
 * 
 * ▪ 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
 * 至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。-- 深入理解Java虚拟机：JVM高级特性与最佳实践(第2版) P212
 * ▪ 创建某类型的数组不会触发该类的初始化
 * ▪ 类的常量属于字面量，字面量在类的准备阶段被存储在常量池中，对这些常量的引用并没有产生对所属类的引用，所以不会触发类的初始化。
 */
public class App {

    /**
     * 对父类静态字段的引用只会触发父类的初始化
     * 
     * 输出：
     * SuperClass init!
     * 123
     */
    @Test
    public void refSuperField() {
        System.out.println(SubClass.value);
    }

    /**
     * 创建某类型的数组不会触发该类的初始化
     * 
     * 输出：
     * 空
     */
    @Test
    public void newArray() {
        @SuppressWarnings("unused")
        SuperClass[] sca = new SuperClass[10];
    }

    /**
     * 类的常量属于字面量，字面量在类的准备阶段被存储在常量池中，对这些常量的引用并没有产生对所属类的引用，所以不会触发类的初始化。
     * 
     * 输出：
     * hello world
     */
    @Test
    public void constants() {
        System.out.println(SubClass.HELLO_WORLD);
    }
}
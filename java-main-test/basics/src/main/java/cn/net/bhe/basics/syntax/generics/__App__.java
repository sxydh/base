package cn.net.bhe.basics.syntax.generics;

/**
 * Java 泛型(generics)是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检
 * 测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。
 * 
 * 泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面泛型无论在程序源码中、编译后的IL
 * 中(Intermediate Language，中间语言，这时候泛型是一个占位符)，或是运行期的CLR中，都是切实存在的，List<int>
 * 与List<String>就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基
 * 于这种方法实现的泛型称为真实泛型。
 * 
 * Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型
 * (Raw Type，也称为裸类型)了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，
 * ArrayList<int>与ArrayList<String>就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型
 * 实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。
 * 
 * 下面是定义泛型方法的规则：
 * ▪ 所有泛型方法声明都有一个类型参数声明部分(由尖括号分隔)，该类型参数声明部分在方法返回类型之前。
 * ▪ 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指
 * 定一个泛型类型名称的标识符。
 * ▪ 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
 * ▪ 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型(像int，double，char的等)。
 */
public class __App__ {
    
    /*
     * 类上的泛型
     */
    class C<T> {}
    
    /*
     * 方法上的泛型
     * 
     * 多个泛型 + 返回泛型 + 形参泛型
     */
    @SuppressWarnings("unchecked")
    public <M extends Comparable<? super M>, N> M m(M m, N n) throws Exception {
        M ret = (M) m.getClass().getConstructor().newInstance();
        return ret;
    }

}
